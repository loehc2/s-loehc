<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Paper Search</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <meta name="referrer" content="no-referrer"/>
  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>
</head>
<body class="bg-gray-50 min-h-screen">
  <header class="bg-white shadow py-6">
    <div class="container mx-auto px-4 flex items-center justify-between">
      <h1 class="text-2xl font-bold text-gray-800">Paper Search</h1>
      <div class="flex items-center gap-3">
        <span id="userEmail" class="text-sm text-gray-600 hidden"></span>
        <button id="loginBtn" class="px-3 py-1 rounded-lg bg-blue-600 text-white hover:bg-blue-700 text-sm">Sign in with Google</button>
        <button id="logoutBtn" class="px-3 py-1 rounded-lg bg-gray-200 text-gray-800 hover:bg-gray-300 text-sm hidden">Sign out</button>
        <a href="./index.html" class="text-blue-600 hover:underline">← Back</a>
      </div>
    </div>
  </header>

  <main class="container mx-auto px-4 py-8">
    <!-- Controls -->
    <div class="bg-white rounded-xl shadow p-4 mb-6 grid grid-cols-1 lg:grid-cols-6 gap-3">
      <input id="query" type="text" class="border rounded-lg px-3 py-2 col-span-2"
             value="(coronavirus OR SARS-CoV-2) AND spike AND antibody response"
             placeholder="Enter search terms"/>
      <input id="author" type="text" class="border rounded-lg px-3 py-2"
             placeholder="author"/>
      <select id="journal" class="border rounded-lg px-3 py-2">
        <option value="">All Journals</option>
        <option value="(nature[journal] OR science[journal] OR cell[journal])">
          CNS
        </option>
        <option value='("Molecular Cell"[journal]
                        OR "The Journal of Cell Biology"[journal]
                        OR "Nature Immunology"[journal]
                        OR "Immunity"[journal]
                        OR "Cell Host & Microbe"[journal]
                        OR "Nature Reviews Molecular Cell Biology"[journal]
                        OR "Nature Medicine"[journal]
                        OR PNAS[journal]
                        OR "Nature Communications"[journal]
                        OR "Nature Structural & Molecular Biology"[journal]
                        OR "Science Translational Medicine"[journal])'>
          Hi
        </option>
          <option value="(biorxiv[source] OR medrxiv[source])">bioRxiv + medRxiv</option>
      </select>
      <select id="dateRange" class="border rounded-lg px-3 py-2">
        <option value="">Any Time</option>
        <option value="1y">Last 1 year</option>
        <option value="3y">Last 3 years</option>
        <option value="5y">Last 5 years</option>
        <option value="custom">Custom Range</option>
      </select>
      <div class="flex gap-1">
        <input type="date" id="startDate" class="border rounded-lg px-2 py-1 hidden">
        <input type="date" id="endDate" class="border rounded-lg px-2 py-1 hidden">
      </div>
      <select id="sort" class="border rounded-lg px-3 py-2">
        <option value="most+recent" selected>Most Recent</option>
        <option value="relevance">Relevance</option>
      </select>
      <button id="run" class="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700">Search</button>
    </div>

    <p id="updated" class="text-sm text-gray-500 mb-6"></p>

    <!-- DOI Search -->
    <section class="mb-12">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-xl font-semibold text-gray-800">DOI Search</h2>
        <a href="saved.html" class="text-blue-600 hover:underline text-sm">Saved Papers</a>
      </div>
      <div class="bg-white rounded-xl shadow p-4 mb-4">
        <div class="flex gap-2">
          <input id="doiInput" type="text" class="flex-1 border rounded-lg px-3 py-2"
                 placeholder="Enter DOI (e.g., 10.1038/nature12373)"/>
          <button id="searchDOI" class="px-4 py-2 rounded-lg bg-blue-600 text-white hover:bg-blue-700">Search</button>
        </div>
      </div>
      <div id="doiResults" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
    </section>

    <!-- PubMed Results -->
    <section class="mb-12">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-xl font-semibold text-gray-800">PubMed</h2>
        <div class="flex items-center gap-3">
          <button id="saveSelected" class="px-3 py-1 rounded-lg bg-green-600 text-white hover:bg-green-700 text-sm hidden">Save Selected</button>
          <a href="saved.html" class="text-blue-600 hover:underline text-sm">Saved Papers</a>
          <div class="text-sm text-gray-500">Auto loaded</div>
        </div>
      </div>
      <div id="pubmed" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
      <div id="pubmedMore" class="mt-4 text-center hidden">
        <button id="loadMorePubmed" class="px-4 py-2 rounded-lg border">Load more</button>
      </div>
    </section>

    <!-- bioRxiv / medRxiv Results -->
    <section class="mb-12">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-xl font-semibold text-gray-800">bioRxiv / medRxiv</h2>
        <div class="flex items-center gap-3 text-sm text-gray-500">
          <span>via biorxiv.org API</span>
          <a href="https://www.biorxiv.org/" target="_blank" rel="noopener" class="text-blue-600 hover:underline">Open site</a>
        </div>
      </div>
      <div id="biorxiv" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
      <div id="biorxivMore" class="mt-4 text-center hidden">
        <button id="loadMoreBiorxiv" class="px-4 py-2 rounded-lg border">Load more</button>
      </div>
    </section>
  </main>

  <footer class="bg-gray-800 text-white py-6 mt-12">
    <div class="container mx-auto px-4 text-center">
      <p>&copy; 2025 SuncheolP</p>
    </div>
  </footer>

  <script>
    // Firebase 설정 (saved.html과 동일한 설정 사용)
    const firebaseConfig = {
      apiKey: "AIzaSyDYvtzLp2CaeMk14navRx9Sgum_J5rZsHo",
      authDomain: "fir-loehc-papers.firebaseapp.com",
      databaseURL: "https://fir-loehc-papers-default-rtdb.firebaseio.com",
      projectId: "fir-loehc-papers",
      storageBucket: "fir-loehc-papers.firebasestorage.app",
      messagingSenderId: "273353748384",
      appId: "1:273353748384:web:47aac0f88c3c666c56bec5",
      measurementId: "G-XKVJH93TKJ"
    };

    let firebaseInitialized = false;
    let database = null;
    let auth = null;
    let provider = null;
    let currentUser = null;
    let papersRef = null;

    // Firebase 초기화
    function initFirebase() {
      // 설정이 완료되었는지 확인
      if (!firebaseConfig.apiKey || firebaseConfig.apiKey.includes('AIza...')) {
        console.log('Firebase not configured. Using localStorage only.');
        updateSyncStatus('offline', 'Local only');
        return false;
      }

      try {
        if (!firebaseInitialized) {
          firebase.initializeApp(firebaseConfig);
          database = firebase.database();
          auth = firebase.auth();
          provider = createProvider();
          firebaseInitialized = true;
          console.log('Firebase initialized successfully');
        }
        return true;
      } catch (error) {
        console.error('Firebase initialization error:', error);
        updateSyncStatus('error', 'Sync error');
        return false;
      }
    }

    function createProvider() {
      const p = new firebase.auth.GoogleAuthProvider();
      // Force account chooser so previous session does not auto-continue
      p.setCustomParameters({ prompt: 'select_account' });
      return p;
    }

    function getUserPapersRef() {
      if (!database || !auth || !auth.currentUser) return null;
      return database.ref(`users/${auth.currentUser.uid}/papers`);
    }

    function startDatabaseSync() {
      if (!firebaseInitialized || !database || !auth || !auth.currentUser) {
        updateSyncStatus('offline', 'Sign in to sync');
        return;
      }

      papersRef = getUserPapersRef();
      papersRef.off();

      loadFromFirebase();

      papersRef.on('value', (snapshot) => {
        const data = snapshot.val();
        // Only overwrite localStorage when remote DB actually has data
        let hasData = false;
        if (Array.isArray(data)) {
          hasData = data.length > 0;
        } else if (data && typeof data === 'object') {
          hasData = Object.keys(data).length > 0;
        }

        if (hasData) {
          const papers = Array.isArray(data) ? data : Object.values(data);
          localStorage.setItem(getStorageKey(), JSON.stringify(papers));
          updateSyncStatus('online', 'Synced');
        } else {
          // Do not overwrite localStorage with an empty remote value.
          // If remote is empty, keep local copy (if any) and show offline/no-data status.
          updateSyncStatus('offline', 'No remote data');
        }
      });
    }

    function stopDatabaseSync() {
      if (papersRef) {
        papersRef.off();
      }
      papersRef = null;
    }

    // 인증 UI 및 상태
    function updateAuthUI(user) {
      const userEmailEl = document.getElementById('userEmail');
      const loginBtn = document.getElementById('loginBtn');
      const logoutBtn = document.getElementById('logoutBtn');

      if (user) {
        userEmailEl.textContent = user.email;
        userEmailEl.classList.remove('hidden');
        logoutBtn.classList.remove('hidden');
        loginBtn.classList.add('hidden');
      } else {
        userEmailEl.classList.add('hidden');
        logoutBtn.classList.add('hidden');
        loginBtn.classList.remove('hidden');
      }
    }

    function initAuth() {
      if (!initFirebase()) return;
      auth.setPersistence(firebase.auth.Auth.Persistence.SESSION).catch((err) => {
        console.warn('Persistence set failed, fallback to default:', err);
      });
      auth.onAuthStateChanged((user) => {
        currentUser = user;
        updateAuthUI(user);
        if (user) {
          updateSyncStatus('online', 'Signed in');
          startDatabaseSync();
        } else {
          updateSyncStatus('offline', 'Sign in to sync');
          stopDatabaseSync();
        }
      });
    }

    function ensureSignedIn(actionName) {
      if (!auth || !auth.currentUser) {
        alert(`구글 로그인 후 ${actionName} 가능합니다.`);
        return false;
      }
      return true;
    }

    function googleLogin() {
      if (!initFirebase()) return;
      const loginProvider = createProvider();
      // Ensure any lingering Firebase session is cleared before prompting
      auth.signOut().catch(()=>{}).finally(() => {
        auth.signInWithPopup(loginProvider)
          .then((result) => {
            const user = result.user;
            console.log("로그인 성공:", user.email);
          })
          .catch((err) => {
            console.error(err);
            alert('로그인에 실패했습니다. 잠시 후 다시 시도해주세요.');
          });
      });
    }

    function googleLogout() {
      if (!auth) return;
      auth.signOut().catch((err) => {
        console.error('로그아웃 실패:', err);
      });
    }

    // 동기화 상태 표시 업데이트
    function updateSyncStatus(status, text) {
      // research.html에는 syncStatus 요소가 없으므로, 이 함수는 오류 없이 실행되도록 둡니다.
      // 필요하다면 여기에 UI 피드백을 추가할 수 있습니다.
    }

    // Firebase에서 데이터 로드
    function loadFromFirebase() {
      if (!firebaseInitialized || !database || !auth || !auth.currentUser) return;
      
      const userRef = getUserPapersRef();
      if (!userRef) return;
      userRef.once('value', (snapshot) => {
        const data = snapshot.val();
        if (data) {
          const papers = Array.isArray(data) ? data : Object.values(data);
          const localPapers = getSavedPapers();
          
          // Firebase 데이터가 더 최신이면 병합
          if (papers.length > 0) {
            const merged = mergePapers(localPapers, papers);
            localStorage.setItem(getStorageKey(), JSON.stringify(merged));
            saveToFirebase(merged);
          }
        }
      });
    }

    // Firebase에 데이터 저장
    function saveToFirebase(papers) {
      if (!firebaseInitialized || !auth || !auth.currentUser) {
        updateSyncStatus('offline', 'Sign in to sync');
        return;
      }
      // Avoid writing an empty array to remote unintentionally
      if (Array.isArray(papers) && papers.length === 0) {
        console.warn('saveToFirebase: empty papers array — skipping remote save to avoid data loss');
        updateSyncStatus('offline', 'No data to save');
        return;
      }

      try {
        updateSyncStatus('online', 'Syncing...');
        const userRef = getUserPapersRef();
        if (!userRef) return;
        userRef.set(papers).then(() => {
          console.log('Saved to Firebase');
          updateSyncStatus('online', 'Synced');
        }).catch((error) => {
          console.error('Firebase save error:', error);
          updateSyncStatus('error', 'Sync failed');
        });
      } catch (error) {
        console.error('Firebase save error:', error);
        updateSyncStatus('error', 'Sync failed');
      }
    }

    // 논문 데이터 병합 (중복 제거)
    function mergePapers(local, remote) {
      const merged = [...local];
      const localPmids = new Set(local.map(p => p.pmid));
      
      remote.forEach(paper => {
        if (!localPmids.has(paper.pmid)) {
          merged.push(paper);
        } else {
          // 기존 논문 업데이트 (카테고리 등)
          const index = merged.findIndex(p => p.pmid === paper.pmid);
          if (index !== -1) {
            merged[index] = { ...merged[index], ...paper };
          }
        }
      });
      
      return merged;
    }

    const updated = document.getElementById('updated');
    const dateRangeSel = document.getElementById('dateRange');
    const startDateInput = document.getElementById('startDate');
    const endDateInput = document.getElementById('endDate');

    dateRangeSel.addEventListener('change', () => {
      if (dateRangeSel.value === 'custom') {
        startDateInput.classList.remove('hidden');
        endDateInput.classList.remove('hidden');
      } else {
        startDateInput.classList.add('hidden');
        endDateInput.classList.add('hidden');
      }
    });

    function setUpdated() {
      updated.textContent = `Last updated: ${new Date().toLocaleString()}`;
    }
    function getQuery() {
      const baseQuery = document.getElementById('query').value.trim();
      const authorFilter = document.getElementById('author').value.trim();
      const journalFilter = document.getElementById('journal').value;
      let query = baseQuery;
      if (authorFilter) {
        query += ` AND ${authorFilter}[author]`;
      }
      return journalFilter ? `${query} AND ${journalFilter}` : query;
    }
    function getDateParams() {
      const today = new Date();
      let mindate = '', maxdate = '';
      if (dateRangeSel.value === '1y') {
        mindate = `${today.getFullYear()-1}/01/01`;
      } else if (dateRangeSel.value === '3y') {
        mindate = `${today.getFullYear()-3}/01/01`;
      } else if (dateRangeSel.value === '5y') {
        mindate = `${today.getFullYear()-5}/01/01`;
      } else if (dateRangeSel.value === 'custom') {
        mindate = startDateInput.value;
        maxdate = endDateInput.value;
      }
      return { mindate, maxdate };
    }

    const pubmedDiv = document.getElementById('pubmed');
    const moreBtnWrap = document.getElementById('pubmedMore');
    const moreBtn = document.getElementById('loadMorePubmed');
    let retstart = 0, retmax = 20, lastQuery = '', lastSort = 'most+recent';
    const biorxivDiv = document.getElementById('biorxiv');
    const biorxivMoreWrap = document.getElementById('biorxivMore');
    const biorxivMoreBtn = document.getElementById('loadMoreBiorxiv');
    let biorxivCursor = 0, biorxivLastQuery = '', biorxivPageSize = 100, biorxivLastPageCount = 0;

    function escapeHtml(str = '') {
      return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
    }

    function toDateString(date) {
      const d = new Date(date);
      const m = String(d.getMonth() + 1).padStart(2, '0');
      const day = String(d.getDate()).padStart(2, '0');
      return `${d.getFullYear()}-${m}-${day}`;
    }

    function normalizeDateForBiorxiv(dateStr) {
      if (!dateStr) return '';
      if (dateStr.includes('-')) return dateStr;
      if (dateStr.includes('/')) {
        const [y, m = '01', d = '01'] = dateStr.split('/');
        return `${y}-${String(m).padStart(2, '0')}-${String(d).padStart(2, '0')}`;
      }
      return dateStr;
    }

    function getBiorxivDateRange() {
      const { mindate, maxdate } = getDateParams();
      const from = normalizeDateForBiorxiv(mindate) || '2013-01-01'; // service launch ~2013
      const to = normalizeDateForBiorxiv(maxdate) || toDateString(new Date());
      return { from, to };
    }

    function simplifyForBiorxiv(rawQuery) {
      if (!rawQuery) return '';
      return rawQuery
        .replace(/[()"]/g, ' ')
        .replace(/\bAND\b|\bOR\b|\bNOT\b/gi, ' ')
        .replace(/[^\w\s-]/g, ' ')
        .replace(/\s+/g, ' ')
        .trim();
    }

    async function fetchPubMed(query, sort='most+recent', append=false) {
      const { mindate, maxdate } = getDateParams();
      const dateParams = mindate ? `&mindate=${mindate}${maxdate ? `&maxdate=${maxdate}` : ''}` : '';
      const term = encodeURIComponent(query);
      const esearch = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esearch.fcgi?db=pubmed&retmode=json&retmax=${retmax}&retstart=${retstart}&sort=${sort}${dateParams}&term=${term}`;
      const e1 = await fetch(esearch).then(r=>r.json()).catch(()=>null);
      const ids = (e1 && e1.esearchresult && e1.esearchresult.idlist) || [];
      if (!append) pubmedDiv.innerHTML = '';
      moreBtnWrap.classList.toggle('hidden', ids.length < retmax);
      if (ids.length === 0) {
        if (!append) pubmedDiv.innerHTML = `<div class="text-gray-500">No results.</div>`;
        return;
      }

      const idStr = ids.join(',');
      const esummary = `https://eutils.ncbi.nlm.nih.gov/entrez/eutils/esummary.fcgi?db=pubmed&retmode=json&id=${idStr}`;
      const e2 = await fetch(esummary).then(r=>r.json()).catch(()=>null);
      const result = e2 && e2.result ? e2.result : {};
      ids.forEach(id => {
        const it = result[id]; if (!it) return;
        const title = it.title || '(no title)';
        const journal = it.fulljournalname || it.source || '';
        const date = it.pubdate || it.epubdate || '';
        const authors = (it.authors||[]).map(a=>a.name).join(', ');
        const pmid = it.uid;
        const link = `https://pubmed.ncbi.nlm.nih.gov/${pmid}/`;
        const cardWrapper = document.createElement('div');
        cardWrapper.className = 'relative bg-white rounded-xl shadow hover:shadow-lg transition p-4';
        cardWrapper.innerHTML = `
          <div class="absolute top-3 right-3">
            <input type="checkbox" class="paper-checkbox w-5 h-5" data-pmid="${pmid}" 
                   data-title="${title.replace(/"/g, '&quot;')}" 
                   data-journal="${journal.replace(/"/g, '&quot;')}" 
                   data-date="${date.replace(/"/g, '&quot;')}" 
                   data-authors="${authors.replace(/"/g, '&quot;')}" 
                   data-link="${link}">
          </div>
          <a href="${link}" target="_blank" rel="noopener" class="block">
            <div class="text-lg font-semibold text-gray-800 mb-1 pr-8">${title}</div>
            <div class="text-sm text-gray-600">${journal} · ${date}</div>
            <div class="text-sm text-gray-600 truncate">${authors}</div>
            <div class="mt-2 text-blue-600 text-sm">PMID: ${pmid}</div>
          </a>
        `;
        pubmedDiv.appendChild(cardWrapper);
      });
    }

    document.getElementById('run').addEventListener('click', () => {
      retstart = 0;
      lastQuery = getQuery();
      lastSort = document.getElementById('sort').value;
      biorxivCursor = 0;
      biorxivLastQuery = lastQuery;
      Promise.all([
        fetchPubMed(lastQuery, lastSort, false),
        fetchBiorxiv(biorxivLastQuery, false)
      ]).then(setUpdated);
    });

    moreBtn.addEventListener('click', () => {
      retstart += retmax;
      fetchPubMed(lastQuery, lastSort, true).then(setUpdated);
    });

    async function fetchBiorxiv(query, append=false) {
      const { from, to } = getBiorxivDateRange();
      const simpleQuery = simplifyForBiorxiv(query) || 'all';
      const term = encodeURIComponent(simpleQuery);
      const url = `https://api.biorxiv.org/details/biorxiv/${from}/${to}/${biorxivCursor}/${term}`;
      if (!append) biorxivDiv.innerHTML = '';

      try {
        const res = await fetch(url).then(r => r.json());
        const items = (res && res.collection) || [];
        const total = Number(res?.messages?.[0]?.total || 0);
        const count = Number(res?.messages?.[0]?.count || items.length);
        biorxivLastPageCount = count || items.length || biorxivPageSize;

        if (items.length === 0) {
          biorxivDiv.innerHTML = '<div class="text-gray-500">No results.</div>';
          biorxivMoreWrap.classList.add('hidden');
          return;
        }

        items.forEach(item => {
          const title = item.title || '(no title)';
          const authors = (item.authors || '').replace(/;/g, '; ');
          const date = item.date || '';
          const doi = item.doi || '';
          const versionSuffix = item.version ? `v${item.version}` : '';
          const serverDomain = item.server === 'medrxiv' ? 'medrxiv' : 'biorxiv';
          const link = doi ? `https://www.${serverDomain}.org/content/${doi}${versionSuffix}` : `https://www.${serverDomain}.org/`;
          const category = item.category ? ` · ${item.category}` : '';

          const cardWrapper = document.createElement('div');
          cardWrapper.className = 'relative bg-white rounded-xl shadow hover:shadow-lg transition p-4';
          cardWrapper.innerHTML = `
            <div class="absolute top-3 right-3">
              <input type="checkbox" class="paper-checkbox w-5 h-5" data-pmid="bio-${escapeHtml(doi)}" 
                     data-title="${escapeHtml(title)}" 
                     data-journal="${escapeHtml(serverDomain)}" 
                     data-date="${escapeHtml(date)}" 
                     data-authors="${escapeHtml(authors)}" 
                     data-link="${escapeHtml(link)}">
            </div>
            <a href="${link}" target="_blank" rel="noopener" class="block">
              <div class="text-lg font-semibold text-gray-800 mb-1 pr-8">${escapeHtml(title)}</div>
              <div class="text-sm text-gray-600">${serverDomain}${category} · ${escapeHtml(date)}</div>
              <div class="text-sm text-gray-600 truncate">${escapeHtml(authors)}</div>
              ${doi ? `<div class="mt-2 text-blue-600 text-sm break-all">DOI: ${escapeHtml(doi)}</div>` : ''}
            </a>
          `;
          biorxivDiv.appendChild(cardWrapper);
        });

        const reachedEnd = total ? (biorxivCursor + biorxivLastPageCount >= total) : (items.length < biorxivLastPageCount);
        biorxivMoreWrap.classList.toggle('hidden', reachedEnd);
      } catch (err) {
        console.error('biorxiv fetch error', err);
        biorxivDiv.innerHTML = '<div class="text-red-500">Error fetching bioRxiv/medRxiv results.</div>';
        biorxivMoreWrap.classList.add('hidden');
      }
    }

    biorxivMoreBtn.addEventListener('click', () => {
      biorxivCursor += biorxivLastPageCount || biorxivPageSize;
      fetchBiorxiv(biorxivLastQuery, true).then(setUpdated);
    });

    // 논문 저장 기능
    const saveBtn = document.getElementById('saveSelected');
    
    function updateSaveButton() {
      const checked = document.querySelectorAll('.paper-checkbox:checked');
      saveBtn.classList.toggle('hidden', checked.length === 0);
    }

    function getStorageKey() {
      return `savedPapers:${auth && auth.currentUser ? auth.currentUser.uid : 'guest'}`;
    }

    pubmedDiv.addEventListener('change', (e) => {
      if (e.target.classList.contains('paper-checkbox')) {
        updateSaveButton();
      }
    });
    biorxivDiv.addEventListener('change', (e) => {
      if (e.target.classList.contains('paper-checkbox')) {
        updateSaveButton();
      }
    });

    function getSavedPapers() {
      const saved = localStorage.getItem(getStorageKey());
      return saved ? JSON.parse(saved) : [];
    }

    function savePapers(papers) {
      localStorage.setItem(getStorageKey(), JSON.stringify(papers));
      // Firebase에도 저장
      if (firebaseInitialized && auth && auth.currentUser) {
        saveToFirebase(papers);
      }
    }

    function savePaper(paperData) {
      if (!ensureSignedIn('저장')) {
        return false;
      }
      const saved = getSavedPapers();
      // 중복 체크
      if (!saved.find(p => p.pmid === paperData.pmid)) {
        saved.push({
          ...paperData,
          savedAt: new Date().toISOString()
        });
        savePapers(saved);
        return true;
      }
      return false;
    }

    saveBtn.addEventListener('click', () => {
      if (!ensureSignedIn('저장')) {
        return;
      }
      const checked = document.querySelectorAll('.paper-checkbox:checked');
      let savedCount = 0;
      
      // Ensure we have the latest papers list from local storage, which is synced by Firebase
      const currentPapers = getSavedPapers();
      const existingPmids = new Set(currentPapers.map(p => p.pmid));

      checked.forEach(checkbox => {
        const pmid = checkbox.dataset.pmid;
        if (!existingPmids.has(pmid)) {
          const paperData = {
            pmid: pmid,
            title: checkbox.dataset.title,
            journal: checkbox.dataset.journal,
            date: checkbox.dataset.date,
            authors: checkbox.dataset.authors,
            link: checkbox.dataset.link,
            savedAt: new Date().toISOString()
          };
          currentPapers.push(paperData);
          existingPmids.add(pmid);
          savedCount++;
        }
        checkbox.checked = false;
      });

      if (savedCount > 0) {
        savePapers(currentPapers);
        alert(`${savedCount} paper${savedCount !== 1 ? 's' : ''} saved.`);
      } else {
        alert('Selected papers are already saved.');
      }
      
      updateSaveButton();
    });

    // DOI Search functionality
    const doiInput = document.getElementById('doiInput');
    const searchDOIBtn = document.getElementById('searchDOI');
    const doiResults = document.getElementById('doiResults');

    async function searchDOI(doi) {
      if (!doi || !doi.trim()) {
        alert('Please enter a DOI');
        return;
      }

      // Clean DOI (remove https://doi.org/ prefix if present)
      let cleanDOI = doi.trim();
      if (cleanDOI.startsWith('http')) {
        cleanDOI = cleanDOI.split('doi.org/')[1] || cleanDOI;
      }
      if (cleanDOI.startsWith('doi:')) {
        cleanDOI = cleanDOI.replace('doi:', '');
      }

      doiResults.innerHTML = '<div class="text-gray-500">Searching...</div>';

      try {
        // Crossref API
        const response = await fetch(`https://api.crossref.org/works/${encodeURIComponent(cleanDOI)}`);
        if (!response.ok) {
          throw new Error('DOI not found');
        }

        const data = await response.json();
        const work = data.message;

        if (!work) {
          throw new Error('DOI not found');
        }

        // Extract information
        const title = work.title ? work.title[0] : 'No title';
        const authors = work.author ? work.author.map(a => {
          const given = a.given || '';
          const family = a.family || '';
          return `${given} ${family}`.trim();
        }).filter(Boolean).join(', ') : 'Unknown authors';
        const journal = work['container-title'] ? work['container-title'][0] : '';
        const date = work.published ? 
          `${work.published['date-parts'][0][0]}-${String(work.published['date-parts'][0][1] || '').padStart(2, '0')}-${String(work.published['date-parts'][0][2] || '').padStart(2, '0')}` : 
          '';
        const doiLink = `https://doi.org/${work.DOI}`;
        const pmid = work.pmid || '';

        // Create card
        const card = document.createElement('div');
        card.className = 'relative bg-white rounded-xl shadow hover:shadow-lg transition p-4';
        card.innerHTML = `
          <div class="absolute top-3 right-3">
            <input type="checkbox" class="doi-checkbox w-5 h-5" data-doi="${work.DOI}"
                   data-title="${title.replace(/"/g, '&quot;')}"
                   data-journal="${journal.replace(/"/g, '&quot;')}"
                   data-date="${date.replace(/"/g, '&quot;')}"
                   data-authors="${authors.replace(/"/g, '&quot;')}"
                   data-link="${doiLink}"
                   data-pmid="${pmid}">
          </div>
          <a href="${doiLink}" target="_blank" rel="noopener" class="block pr-8">
            <div class="text-lg font-semibold text-gray-800 mb-1">${title}</div>
            <div class="text-sm text-gray-600">${journal}${date ? ' · ' + date : ''}</div>
            <div class="text-sm text-gray-600 truncate">${authors}</div>
            <div class="mt-2 text-blue-600 text-sm">DOI: ${work.DOI}</div>
            ${pmid ? `<div class="mt-1 text-blue-600 text-sm">PMID: ${pmid}</div>` : ''}
          </a>
        `;
        doiResults.innerHTML = '';
        doiResults.appendChild(card);

        // Add save button if not exists
        if (!document.getElementById('saveDOIBtn')) {
          const saveDOIBtn = document.createElement('button');
          saveDOIBtn.id = 'saveDOIBtn';
          saveDOIBtn.className = 'px-3 py-1 rounded-lg bg-green-600 text-white hover:bg-green-700 text-sm hidden mt-2';
          saveDOIBtn.textContent = 'Save';
          saveDOIBtn.addEventListener('click', () => {
            const checkbox = document.querySelector('.doi-checkbox:checked');
            if (checkbox) {
              const paperData = {
                pmid: checkbox.dataset.pmid || `doi-${checkbox.dataset.doi}`,
                title: checkbox.dataset.title,
                journal: checkbox.dataset.journal,
                date: checkbox.dataset.date,
                authors: checkbox.dataset.authors,
                link: checkbox.dataset.link
              };
              if (savePaper(paperData)) {
                alert('Paper saved.');
                checkbox.checked = false;
                saveDOIBtn.classList.add('hidden');
              } else {
                alert('Paper already saved.');
              }
            }
          });
          doiResults.appendChild(saveDOIBtn);
        }

        // Update save button visibility
        const saveDOIBtn = document.getElementById('saveDOIBtn');
        const checkbox = document.querySelector('.doi-checkbox');
        checkbox.addEventListener('change', () => {
          if (saveDOIBtn) {
            saveDOIBtn.classList.toggle('hidden', !checkbox.checked);
          }
        });

      } catch (error) {
        console.error('DOI search error:', error);
        doiResults.innerHTML = `<div class="text-red-500">Error: ${error.message}. Please check the DOI and try again.</div>`;
      }
    }

    searchDOIBtn.addEventListener('click', () => {
      searchDOI(doiInput.value);
    });

    doiInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        searchDOI(doiInput.value);
      }
    });

    (function init(){
      // Firebase 초기화 및 인증 설정
      initFirebase();
      initAuth();
      document.getElementById('loginBtn').addEventListener('click', googleLogin);
      document.getElementById('logoutBtn').addEventListener('click', googleLogout);
      
      lastQuery = getQuery();
      lastSort  = document.getElementById('sort').value;
      biorxivLastQuery = lastQuery;
      Promise.all([
        fetchPubMed(lastQuery, lastSort, false),
        fetchBiorxiv(biorxivLastQuery, false)
      ]).then(setUpdated);
    })();
  </script>
</body>
</html>
